# W26 Lua VM Runtime Patching Toolkit

## English version:

These three files form a toolkit for runtime modification of the mobile game BLEACH: Soul Resonance (com.bleach.apj). The game runs on Android and uses a custom Lua VM implementation called W26 bytecode, which is embedded in the libgame.so library. This custom VM is similar to Lua 5.3/5.4 but uses a proprietary instruction format. The game's combat logic, including damage calculations, is implemented in Lua scripts that are compiled to W26 bytecode and stored in Proto structures. Each Proto contains bytecode instructions and a constants table. The main damage formula is located in Proto P10, which is loaded from the combat_api_damageFunc.lua module. Damage calculations use MULK (multiply by constant) instructions that reference float values from the constants table, specifically k[14] equals 0.01 and k[59] or k[60] equals 0.0001.

The first file, run_frida_js.py, is a universal Python launcher for Frida JavaScript scripts. It handles ADB device detection, automatically selects USB devices, sets up frida-server on the Android device, and manages process attachment or spawning. The script supports both spawn and attach modes, with automatic detection of the BLEACH process. It manages file dumps including Lua chunks, Proto dumps, and network traffic files. The launcher also provides an interactive RPC menu that allows runtime adjustment of damage multipliers without restarting the game.

The second file, lua_w26_proto_patch.js, is a Frida JavaScript script that performs runtime patching of the game's bytecode. It hooks the loadFunction() function in libgame.so, which is responsible for loading Proto structures from compiled Lua chunks. When a Proto is loaded, the script checks if it matches the target Proto P10 by examining its code size and constant count. If it matches, the script patches specific W26 bytecode instructions in memory. It replaces MULK instructions that use the constant 0.0001 (referencing k[59] or k[60]) with instructions that use 0.01 (referencing k[14]). The patching occurs at specific program counter offsets, which are 481 and 600 for the new game version. Additionally, the script modifies the k[14] float constant value directly in memory, allowing dynamic control of the damage multiplier. The script also dumps combat_api_damageFunc.lua chunks for offline analysis.

The third file, W26_Lua_VM_Damage_Guide.txt, is a reverse engineering guide that documents the entire methodology for working with Lua VM-based games. It explains the Proto structure format, the W26 bytecode instruction set, and the patching methodology. The guide provides step-by-step instructions for locating damage formulas in games, including how to identify target Proto structures and analyze bytecode patterns. It includes a real-world case study documenting the process of updating patches after a game update, where the Proto P10 changed from size 577/68 to 648/71, requiring identification of new instruction offsets. The guide also contains troubleshooting information for common scenarios where patches break after game updates.

The system works by first connecting to an Android device via ADB using the Python launcher. The launcher ensures frida-server is running on the device and sets up port forwarding. It then injects the JavaScript patching script into the BLEACH process. The script installs a hook on the loadFunction() function, which intercepts every Proto structure as it's loaded into memory. When the combat_api_damageFunc.lua module loads, the script identifies Proto P10 by matching its code size and constant count against known values. Once identified, the script patches the MULK instructions in the Proto's code array at the specified offsets, replacing the damage reduction constant with a damage amplification constant. It also modifies the k[14] float value to allow further fine-tuning. All changes take effect immediately in memory without requiring a game restart, allowing real-time damage modification during gameplay.

## Русская версия:

Эти три файла образуют набор инструментов для модификации в рантайме мобильной игры BLEACH: Soul Resonance (com.bleach.apj). Игра работает на Android и использует кастомную реализацию Lua VM под названием байткод W26, которая встроена в библиотеку libgame.so. Эта кастомная VM похожа на Lua 5.3/5.4, но использует проприетарный формат инструкций. Боевая логика игры, включая расчеты урона, реализована в Lua скриптах, которые компилируются в байткод W26 и хранятся в структурах Proto. Каждая Proto содержит инструкции байткода и таблицу констант. Основная формула урона находится в Proto P10, которая загружается из модуля combat_api_damageFunc.lua. Расчеты урона используют инструкции MULK (умножение на константу), которые ссылаются на float значения из таблицы констант, конкретно k[14] равен 0.01, а k[59] или k[60] равен 0.0001.

Первый файл, run_frida_js.py, это универсальный Python лаунчер для Frida JavaScript скриптов. Он обрабатывает определение ADB устройств, автоматически выбирает USB устройства, настраивает frida-server на Android устройстве и управляет подключением или запуском процессов. Скрипт поддерживает режимы spawn и attach с автоматическим определением процесса BLEACH. Он управляет дампами файлов, включая Lua чанки, Proto дампы и файлы сетевого трафика. Лаунчер также предоставляет интерактивное RPC меню, которое позволяет настраивать множители урона в рантайме без перезапуска игры.

Второй файл, lua_w26_proto_patch.js, это Frida JavaScript скрипт, который выполняет патчинг байткода игры в рантайме. Он перехватывает функцию loadFunction() в libgame.so, которая отвечает за загрузку структур Proto из скомпилированных Lua чанков. Когда Proto загружается, скрипт проверяет, соответствует ли она целевой Proto P10, анализируя размер кода и количество констант. Если совпадает, скрипт патчит конкретные инструкции W26 байткода в памяти. Он заменяет инструкции MULK, использующие константу 0.0001 (ссылаясь на k[59] или k[60]), на инструкции, использующие 0.01 (ссылаясь на k[14]). Патчинг происходит на конкретных смещениях программного счетчика, которые равны 481 и 600 для новой версии игры. Дополнительно скрипт модифицирует значение float константы k[14] напрямую в памяти, позволяя динамический контроль множителя урона. Скрипт также дампит чанки combat_api_damageFunc.lua для оффлайнового анализа.

Третий файл, W26_Lua_VM_Damage_Guide.txt, это руководство по реверс-инжинирингу, которое документирует всю методологию работы с играми на основе Lua VM. Оно объясняет формат структуры Proto, набор инструкций байткода W26 и методологию патчинга. Руководство предоставляет пошаговые инструкции по поиску формул урона в играх, включая способы идентификации целевых структур Proto и анализа паттернов байткода. Оно включает реальный кейс, документирующий процесс обновления патчей после обновления игры, где Proto P10 изменилась с размера 577/68 на 648/71, потребовав идентификации новых смещений инструкций. Руководство также содержит информацию по устранению неполадок для типичных сценариев, когда патчи ломаются после обновлений игры.

Система работает следующим образом: сначала происходит подключение к Android устройству через ADB с помощью Python лаунчера. Лаунчер обеспечивает запуск frida-server на устройстве и настраивает проброс портов. Затем он внедряет JavaScript скрипт патчинга в процесс BLEACH. Скрипт устанавливает хук на функцию loadFunction(), который перехватывает каждую структуру Proto по мере её загрузки в память. Когда загружается модуль combat_api_damageFunc.lua, скрипт идентифицирует Proto P10, сопоставляя размер её кода и количество констант с известными значениями. После идентификации скрипт патчит инструкции MULK в массиве кода Proto на указанных смещениях, заменяя константу снижения урона на константу усиления урона. Он также модифицирует float значение k[14] для дальнейшей тонкой настройки. Все изменения вступают в силу немедленно в памяти без необходимости перезапуска игры, позволяя модификацию урона в реальном времени во время геймплея.

---

## Tags

game-hacking, game-modding, android-hacking, mobile-game-hacking, reverse-engineering, runtime-patching, memory-patching, bytecode-patching, frida, frida-scripts, lua-vm, w26-bytecode, proto-structures, dynamic-instrumentation, hooking, interceptor, adb, android-debugging, bleach-soul-resonance, com.bleach.apj, libgame.so, damage-formula, combat-system, python, javascript, frida-javascript, reverse-engineering-tools, binary-analysis, bytecode-analysis, damage-multiplier, game-mechanics-modification, runtime-modification, real-time-patching, game-analysis, security-research, lua-5.3, lua-5.4, custom-vm, virtual-machine, instruction-set, opcode-patching, constant-modification, memory-editing

